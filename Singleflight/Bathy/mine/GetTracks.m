function tracks = GetTracks( input, meshSize, demand, nFrames)%inputDir, MeshSize, TracksPerFrame, nFrames
%GetTracks Compute tracks by KLT
%   Use KLT to track evenly fistributed track points
%   input: the path to images
%   meshSize: the meshSize of video stitching
    fileList = dir(input);
    fileList = fileList(3:length(fileList));
    if ~exist('nFrames', 'var') || nFrames > length(fileList)
        nFrames = length(fileList); 
    end
    
    tracks = TrackLib(nFrames);    
    tracks.maxLen = nFrames;
    
    
    tracker = vision.PointTracker('NumPyramidLevels', 3, 'MaxBidirectionalError', 1, 'BlockSize', [51 51]);
    %tracker = vision.PointTracker('MaxBidirectionalError', 1);
    fileName = fileList(1).name;
    frame = imread([input fileName]);
    [H, W, ~] = size(frame);    
    tracks.videoWidth = W;    
    tracks.videoHeight = H;
    
    f_laplacian = fspecial('laplacian',0);
    frame = frame - imfilter(frame, f_laplacian);
    
    livePoints = getMorePoints(frame, meshSize, 0, [], demand);%这一步应该就是选出一些点出来，无论用什么算法，这些点将用作第一帧的初始跟踪点
    initialize(tracker, livePoints, frame);%初始化非线性估计，这是第一帧的
    tracks.addPoints(livePoints, 1);
    fprintf('%5d', 1);
    for frameIndex = 2:nFrames
        fprintf('%5d', frameIndex);
        if mod(frameIndex, 20) == 0
            fprintf('\n') ;
        end        
        fileName = fileList(frameIndex).name;
        frame = imread([input fileName]);
        
        f_laplacian = fspecial('laplacian',0);%锐化，有利于增加可检测角点
        frame = frame - imfilter(frame, f_laplacian);   
        
        
        [livePoints, validity] = step(tracker, frame);%输入：上一帧的跟踪轨迹、当前帧，输出当前帧的跟踪点结果，有效索引， 无效的都是没有动的？还是？？
        age = true(size(validity));
        age(tracks.len(tracks.live) == tracks.maxLen) = false;%?这一步到底是干嘛的？
%         fprintf('=> %d\t%d\n', size(tracks.live, 2), size(validity, 1));
        if size(tracks.live, 2) ~= size(validity, 1)
            disp('?') ;
        end
        tracks.endPoints(validity & age, frameIndex);
        tracks.updatePoints(livePoints(validity & age, :), frameIndex);
        
        % end too old tracks 
        morePoints = getMorePoints(frame, meshSize, length(tracks.live), livePoints(validity == true, :), demand);
        tracks.addPoints(morePoints, frameIndex);
        livePoints = [livePoints(validity & age, :); morePoints];
        setPoints(tracker, livePoints);
        marked = insertMarker(frame, livePoints, '*');
        imshow(marked);        
    end
    tracks.endPoints(false(length(tracks.live), 1), length(fileList) + 1);
end

function pointsMore = getMorePoints(frame, meshSize, nP, oldpoints, demand)%frame_s, meshSize, 0, [], demand
    demand = demand / (meshSize * meshSize);%meshSize=16,demand = 2
    votes = zeros(meshSize);
    [H, W, ~] = size(frame);
    threshold = 0.5;
    if nP > 0
        votes = getVotes(frame, meshSize, oldpoints);
    end
    points = [];%按照第一帧来讲np=0
    
    NDIM = ndims(frame);
    
    for row = 1:meshSize
        for col = 1:meshSize
            if votes(row, col) < demand * 0.8
                nMore = floor(demand - votes(row, col));
                roi = [1 + (col - 1) * W / meshSize, 1 + (row - 1) * H / meshSize, W / meshSize - 1, H / meshSize - 1];  
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                if NDIM > 2
                    pNew = detectMinEigenFeatures(rgb2gray(frame), 'ROI', roi, 'MinQuality', threshold); 
                else
                    pNew = detectMinEigenFeatures(frame, 'ROI', roi, 'MinQuality', threshold); 
                end
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                while (size(pNew, 1) < nMore) && threshold > 0.1
                    threshold = threshold - 0.1; 
                    threshold = max(threshold, 0);
                   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    if NDIM > 2
                        pNew = detectMinEigenFeatures(rgb2gray(frame), 'ROI', roi, 'MinQuality', threshold); 
                    else
                        pNew = detectMinEigenFeatures(frame, 'ROI', roi, 'MinQuality', threshold); 
                    end
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                end
                if nMore < size(pNew, 1)
                    pNew = pNew.selectStrongest(nMore);
                end
                points = [points; pNew.Location];
            end
        end
    end
    pointsMore = points;
    
end

function votes = getVotes(frame, meshSize, points)%投票
    [H, W, ~] = size(frame);    
    qH = H / meshSize;
    qW = W / meshSize;
    index = floor(points(:, 1) / qW) * meshSize + (floor(points(:, 2) / qH)) + 1; 
    voting = histcounts([index; 1; meshSize*meshSize], meshSize*meshSize);  %统计直方图，然后加一个1，下面再减一个1，加一个meshSize*meshSize,下面再减去一个
    voting(1) = voting(1) - 1;
    voting(meshSize * meshSize) = voting(meshSize*meshSize) - 1;    
    votes = reshape(voting, [meshSize meshSize]);%将其reshape，也就是按照直方图的分布按照meshSize * meshSize平均分。，
end
